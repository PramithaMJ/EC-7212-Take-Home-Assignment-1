{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "a71b836a",
   "metadata": {},
   "source": [
    "# EC7212 â€“ Computer Vision and Image Processing: Take Home Assignment 1\n",
    "\n",
    "This notebook implements various image processing operations as required for Assignment 1:\n",
    "\n",
    "1. Intensity level reduction from 256 to any power of 2\n",
    "2. Spatial averaging with different neighborhood sizes (3x3, 10x10, 20x20)\n",
    "3. Image rotation by 45 and 90 degrees\n",
    "4. Spatial resolution reduction by block averaging (3x3, 5x5, 7x7)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "f6dc51f4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Requirement already satisfied: opencv-python in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (4.11.0.86)\n",
      "Requirement already satisfied: numpy>=1.21.2 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from opencv-python) (1.24.3)\n",
      "\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m25.0.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.1.1\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\n",
      "\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m25.0.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.1.1\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\n",
      "Requirement already satisfied: matplotlib in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (3.7.2)\n",
      "Requirement already satisfied: contourpy>=1.0.1 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (1.0.5)\n",
      "Requirement already satisfied: cycler>=0.10 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (0.11.0)\n",
      "Requirement already satisfied: matplotlib in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (3.7.2)\n",
      "Requirement already satisfied: contourpy>=1.0.1 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (1.0.5)\n",
      "Requirement already satisfied: cycler>=0.10 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (0.11.0)\n",
      "Requirement already satisfied: fonttools>=4.22.0 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (4.25.0)\n",
      "Requirement already satisfied: kiwisolver>=1.0.1 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (1.4.4)\n",
      "Requirement already satisfied: numpy>=1.20 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (1.24.3)\n",
      "Requirement already satisfied: packaging>=20.0 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (24.2)\n",
      "Requirement already satisfied: pillow>=6.2.0 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (10.0.1)\n",
      "Requirement already satisfied: pyparsing<3.1,>=2.3.1 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (3.0.9)\n",
      "Requirement already satisfied: python-dateutil>=2.7 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (2.9.0.post0)\n",
      "Requirement already satisfied: six>=1.5 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from python-dateutil>=2.7->matplotlib) (1.17.0)\n",
      "Requirement already satisfied: fonttools>=4.22.0 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (4.25.0)\n",
      "Requirement already satisfied: kiwisolver>=1.0.1 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (1.4.4)\n",
      "Requirement already satisfied: numpy>=1.20 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (1.24.3)\n",
      "Requirement already satisfied: packaging>=20.0 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (24.2)\n",
      "Requirement already satisfied: pillow>=6.2.0 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (10.0.1)\n",
      "Requirement already satisfied: pyparsing<3.1,>=2.3.1 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (3.0.9)\n",
      "Requirement already satisfied: python-dateutil>=2.7 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from matplotlib) (2.9.0.post0)\n",
      "Requirement already satisfied: six>=1.5 in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (from python-dateutil>=2.7->matplotlib) (1.17.0)\n",
      "\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m25.0.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.1.1\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\n",
      "\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m25.0.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.1.1\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\n",
      "Requirement already satisfied: numpy in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (1.24.3)\n",
      "Requirement already satisfied: numpy in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (1.24.3)\n",
      "\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m25.0.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.1.1\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\n",
      "\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m25.0.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.1.1\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\n",
      "Requirement already satisfied: Pillow in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (10.0.1)\n",
      "Requirement already satisfied: Pillow in /Users/pramithajayasooriya/anaconda3/lib/python3.11/site-packages (10.0.1)\n",
      "\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m25.0.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.1.1\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\n",
      "\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m25.0.1\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m25.1.1\u001b[0m\n",
      "\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0m\n"
     ]
    }
   ],
   "source": [
    "# Install required packages if not already installed\n",
    "!pip install opencv-python\n",
    "!pip install matplotlib\n",
    "!pip install numpy\n",
    "!pip install Pillow  # PIL library"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "3d8261fa",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from PIL import Image\n",
    "import cv2\n",
    "import os\n",
    "\n",
    "# Set up matplotlib for better display in notebook\n",
    "%matplotlib inline\n",
    "plt.rcParams['figure.figsize'] = [12, 8]\n",
    "plt.rcParams['figure.dpi'] = 80"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "0f741a50",
   "metadata": {},
   "outputs": [],
   "source": [
    "def load_and_display_image(image_path):\n",
    "    \"\"\"\n",
    "    Load an image from path and display it\n",
    "    \n",
    "    Args:\n",
    "        image_path (str): Path to the image file\n",
    "        \n",
    "    Returns:\n",
    "        ndarray: Loaded image in numpy array format\n",
    "    \"\"\"\n",
    "    # Check if image path exists\n",
    "    if not os.path.exists(image_path):\n",
    "        print(f\"Image file not found: {image_path}\")\n",
    "        return None\n",
    "    \n",
    "    # Load the image\n",
    "    img = cv2.imread(image_path)\n",
    "    \n",
    "    # Convert from BGR to RGB (OpenCV loads images in BGR)\n",
    "    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n",
    "    \n",
    "    # Display the original image\n",
    "    plt.figure()\n",
    "    plt.imshow(img_rgb)\n",
    "    plt.title('Original Image')\n",
    "    plt.axis('off')\n",
    "    plt.show()\n",
    "    \n",
    "    return img_rgb\n",
    "\n",
    "# Specify the path to your test image\n",
    "# Example: image_path = 'path/to/your/image.jpg'\n",
    "image_path = 'test_image.jpg'  # Replace with your actual image path\n",
    "\n",
    "# Uncomment the line below to load and display the image\n",
    "# original_image = load_and_display_image(image_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "86c2e2d1",
   "metadata": {},
   "source": [
    "## Task 1: Reducing Intensity Levels\n",
    "\n",
    "Implement a function to reduce the number of intensity levels in an image from 256 to any integer power of 2."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "204e3331",
   "metadata": {},
   "outputs": [],
   "source": [
    "def reduce_intensity_levels(image, levels):\n",
    "    \"\"\"\n",
    "    Reduce the number of intensity levels in an image\n",
    "    \n",
    "    Args:\n",
    "        image (ndarray): Input image\n",
    "        levels (int): Target number of intensity levels (must be a power of 2)\n",
    "        \n",
    "    Returns:\n",
    "        ndarray: Image with reduced intensity levels\n",
    "    \"\"\"\n",
    "    # Check if levels is a power of 2\n",
    "    if not (levels & (levels - 1) == 0) or levels <= 0:\n",
    "        raise ValueError(\"Levels must be a positive integer power of 2\")\n",
    "    \n",
    "    # Make a copy of the image to avoid modifying the original\n",
    "    reduced_img = image.copy().astype(np.float32)\n",
    "    \n",
    "    # Calculate the factor to divide by to get the reduced levels\n",
    "    factor = 256 / levels\n",
    "    \n",
    "    # Quantize the image\n",
    "    reduced_img = np.floor(reduced_img / factor) * factor\n",
    "    \n",
    "    # Ensure values are within the valid range [0, 255]\n",
    "    reduced_img = np.clip(reduced_img, 0, 255).astype(np.uint8)\n",
    "    \n",
    "    return reduced_img\n",
    "\n",
    "def display_intensity_reduction_results(image, levels_list):\n",
    "    \"\"\"\n",
    "    Display original image alongside images with reduced intensity levels\n",
    "    \n",
    "    Args:\n",
    "        image (ndarray): Original image\n",
    "        levels_list (list): List of intensity levels to reduce to\n",
    "    \"\"\"\n",
    "    if image is None:\n",
    "        print(\"No image to process\")\n",
    "        return\n",
    "    \n",
    "    # Calculate number of rows and columns for subplot grid\n",
    "    n = len(levels_list) + 1  # +1 for the original image\n",
    "    cols = 3\n",
    "    rows = (n + cols - 1) // cols  # Ceiling division\n",
    "    \n",
    "    plt.figure(figsize=(15, rows * 5))\n",
    "    \n",
    "    # Display original image\n",
    "    plt.subplot(rows, cols, 1)\n",
    "    plt.imshow(image)\n",
    "    plt.title('Original (256 levels)')\n",
    "    plt.axis('off')\n",
    "    \n",
    "    # Display images with reduced intensity levels\n",
    "    for i, levels in enumerate(levels_list, 2):\n",
    "        reduced = reduce_intensity_levels(image, levels)\n",
    "        plt.subplot(rows, cols, i)\n",
    "        plt.imshow(reduced)\n",
    "        plt.title(f'{levels} Intensity Levels')\n",
    "        plt.axis('off')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    return\n",
    "\n",
    "# Example usage (uncomment to test):\n",
    "# if original_image is not None:\n",
    "#     # List of intensity levels to reduce to (powers of 2)\n",
    "#     levels_list = [128, 64, 32, 16, 8, 4, 2]\n",
    "#     display_intensity_reduction_results(original_image, levels_list)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fff32783",
   "metadata": {},
   "source": [
    "## Task 2: Spatial Averaging\n",
    "\n",
    "Implement spatial averaging with different neighborhood sizes (3x3, 10x10, 20x20)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0c57b57c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def spatial_average(image, kernel_size):\n",
    "    \"\"\"\n",
    "    Perform spatial averaging on an image using a specified kernel size\n",
    "    \n",
    "    Args:\n",
    "        image (ndarray): Input image\n",
    "        kernel_size (int): Size of the square kernel (e.g., 3 for 3x3)\n",
    "        \n",
    "    Returns:\n",
    "        ndarray: Spatially averaged image\n",
    "    \"\"\"\n",
    "    # Create the averaging kernel\n",
    "    kernel = np.ones((kernel_size, kernel_size), np.float32) / (kernel_size * kernel_size)\n",
    "    \n",
    "    # Apply the kernel to each channel separately if the image is RGB\n",
    "    if len(image.shape) == 3:  # RGB image\n",
    "        averaged_img = np.zeros_like(image)\n",
    "        for c in range(image.shape[2]):\n",
    "            averaged_img[:, :, c] = cv2.filter2D(image[:, :, c], -1, kernel)\n",
    "    else:  # Grayscale image\n",
    "        averaged_img = cv2.filter2D(image, -1, kernel)\n",
    "    \n",
    "    return averaged_img.astype(np.uint8)\n",
    "\n",
    "def display_spatial_averaging_results(image, kernel_sizes):\n",
    "    \"\"\"\n",
    "    Display original image alongside images processed with different averaging kernel sizes\n",
    "    \n",
    "    Args:\n",
    "        image (ndarray): Original image\n",
    "        kernel_sizes (list): List of kernel sizes to apply\n",
    "    \"\"\"\n",
    "    if image is None:\n",
    "        print(\"No image to process\")\n",
    "        return\n",
    "    \n",
    "    # Calculate number of rows and columns for subplot grid\n",
    "    n = len(kernel_sizes) + 1  # +1 for the original image\n",
    "    cols = 2\n",
    "    rows = (n + cols - 1) // cols  # Ceiling division\n",
    "    \n",
    "    plt.figure(figsize=(15, rows * 6))\n",
    "    \n",
    "    # Display original image\n",
    "    plt.subplot(rows, cols, 1)\n",
    "    plt.imshow(image)\n",
    "    plt.title('Original Image')\n",
    "    plt.axis('off')\n",
    "    \n",
    "    # Display spatially averaged images\n",
    "    for i, size in enumerate(kernel_sizes, 2):\n",
    "        averaged = spatial_average(image, size)\n",
    "        plt.subplot(rows, cols, i)\n",
    "        plt.imshow(averaged)\n",
    "        plt.title(f'{size}x{size} Spatial Average')\n",
    "        plt.axis('off')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    return\n",
    "\n",
    "# Example usage (uncomment to test):\n",
    "# if original_image is not None:\n",
    "#     # List of kernel sizes to apply\n",
    "#     kernel_sizes = [3, 10, 20]\n",
    "#     display_spatial_averaging_results(original_image, kernel_sizes)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "df36bd36",
   "metadata": {},
   "source": [
    "## Task 3: Image Rotation\n",
    "\n",
    "Implement image rotation by 45 and 90 degrees."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ea35650f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def rotate_image(image, angle):\n",
    "    \"\"\"\n",
    "    Rotate an image by the specified angle\n",
    "    \n",
    "    Args:\n",
    "        image (ndarray): Input image\n",
    "        angle (float): Rotation angle in degrees\n",
    "        \n",
    "    Returns:\n",
    "        ndarray: Rotated image\n",
    "    \"\"\"\n",
    "    if image is None:\n",
    "        return None\n",
    "    \n",
    "    # Get the image height and width\n",
    "    height, width = image.shape[:2]\n",
    "    \n",
    "    # Calculate the center of the image\n",
    "    center = (width // 2, height // 2)\n",
    "    \n",
    "    # Calculate the rotation matrix\n",
    "    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n",
    "    \n",
    "    # For non-90 degree rotations, calculate the new image dimensions\n",
    "    # to avoid cropping\n",
    "    if angle % 90 != 0:\n",
    "        # Calculate new image dimensions\n",
    "        abs_cos = abs(rotation_matrix[0, 0])\n",
    "        abs_sin = abs(rotation_matrix[0, 1])\n",
    "        \n",
    "        # Calculate new width and height\n",
    "        new_width = int(height * abs_sin + width * abs_cos)\n",
    "        new_height = int(height * abs_cos + width * abs_sin)\n",
    "        \n",
    "        # Adjust the rotation matrix to consider the new dimensions\n",
    "        rotation_matrix[0, 2] += (new_width / 2) - center[0]\n",
    "        rotation_matrix[1, 2] += (new_height / 2) - center[1]\n",
    "        \n",
    "        # Perform the rotation\n",
    "        rotated_img = cv2.warpAffine(image, rotation_matrix, (new_width, new_height))\n",
    "    else:  # 90-degree rotations\n",
    "        # For 90-degree rotations, we can use simpler logic\n",
    "        if angle % 360 == 90:\n",
    "            rotated_img = cv2.transpose(image)\n",
    "            rotated_img = cv2.flip(rotated_img, 1)  # Flip horizontally\n",
    "        elif angle % 360 == 180:\n",
    "            rotated_img = cv2.flip(image, -1)  # Flip both horizontally and vertically\n",
    "        elif angle % 360 == 270:\n",
    "            rotated_img = cv2.transpose(image)\n",
    "            rotated_img = cv2.flip(rotated_img, 0)  # Flip vertically\n",
    "        else:  # 0 degrees or 360 degrees\n",
    "            rotated_img = image.copy()\n",
    "    \n",
    "    return rotated_img\n",
    "\n",
    "def display_rotation_results(image, angles):\n",
    "    \"\"\"\n",
    "    Display original image alongside rotated images\n",
    "    \n",
    "    Args:\n",
    "        image (ndarray): Original image\n",
    "        angles (list): List of rotation angles in degrees\n",
    "    \"\"\"\n",
    "    if image is None:\n",
    "        print(\"No image to process\")\n",
    "        return\n",
    "    \n",
    "    # Calculate number of rows and columns for subplot grid\n",
    "    n = len(angles) + 1  # +1 for the original image\n",
    "    cols = 2\n",
    "    rows = (n + cols - 1) // cols  # Ceiling division\n",
    "    \n",
    "    plt.figure(figsize=(15, rows * 6))\n",
    "    \n",
    "    # Display original image\n",
    "    plt.subplot(rows, cols, 1)\n",
    "    plt.imshow(image)\n",
    "    plt.title('Original Image')\n",
    "    plt.axis('off')\n",
    "    \n",
    "    # Display rotated images\n",
    "    for i, angle in enumerate(angles, 2):\n",
    "        rotated = rotate_image(image, angle)\n",
    "        plt.subplot(rows, cols, i)\n",
    "        plt.imshow(rotated)\n",
    "        plt.title(f'Rotated by {angle} degrees')\n",
    "        plt.axis('off')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    return\n",
    "\n",
    "# Example usage (uncomment to test):\n",
    "# if original_image is not None:\n",
    "#     angles = [45, 90]\n",
    "#     display_rotation_results(original_image, angles)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "78ef90fa",
   "metadata": {},
   "source": [
    "## Task 4: Spatial Resolution Reduction by Block Averaging\n",
    "\n",
    "Implement spatial resolution reduction by averaging non-overlapping blocks of sizes 3x3, 5x5, and 7x7."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "02e26087",
   "metadata": {},
   "outputs": [],
   "source": [
    "def reduce_spatial_resolution(image, block_size):\n",
    "    \"\"\"\n",
    "    Reduce spatial resolution by replacing each block with its average\n",
    "    \n",
    "    Args:\n",
    "        image (ndarray): Input image\n",
    "        block_size (int): Size of non-overlapping blocks (e.g., 3 for 3x3)\n",
    "        \n",
    "    Returns:\n",
    "        ndarray: Image with reduced spatial resolution\n",
    "    \"\"\"\n",
    "    if image is None:\n",
    "        return None\n",
    "    \n",
    "    # Get the dimensions of the image\n",
    "    height, width = image.shape[:2]\n",
    "    \n",
    "    # Calculate the new dimensions (truncating if necessary)\n",
    "    new_height = (height // block_size) * block_size\n",
    "    new_width = (width // block_size) * block_size\n",
    "    \n",
    "    # Truncate the image if needed to make it divisible by block_size\n",
    "    truncated_img = image[:new_height, :new_width].copy()\n",
    "    \n",
    "    # Create a new image for the result\n",
    "    if len(image.shape) == 3:  # RGB image\n",
    "        channels = image.shape[2]\n",
    "        result_img = np.zeros((new_height // block_size, new_width // block_size, channels), dtype=np.uint8)\n",
    "    else:  # Grayscale image\n",
    "        result_img = np.zeros((new_height // block_size, new_width // block_size), dtype=np.uint8)\n",
    "    \n",
    "    # Process each block and replace with average\n",
    "    for i in range(0, new_height, block_size):\n",
    "        for j in range(0, new_width, block_size):\n",
    "            # Extract the block\n",
    "            block = truncated_img[i:i+block_size, j:j+block_size]\n",
    "            \n",
    "            # Calculate the average of the block\n",
    "            block_avg = np.mean(block, axis=(0, 1)).astype(np.uint8)\n",
    "            \n",
    "            # Assign average to corresponding pixel in result\n",
    "            result_img[i // block_size, j // block_size] = block_avg\n",
    "    \n",
    "    return result_img\n",
    "\n",
    "def display_resolution_reduction_results(image, block_sizes):\n",
    "    \"\"\"\n",
    "    Display original image alongside images with reduced spatial resolution\n",
    "    \n",
    "    Args:\n",
    "        image (ndarray): Original image\n",
    "        block_sizes (list): List of block sizes to apply\n",
    "    \"\"\"\n",
    "    if image is None:\n",
    "        print(\"No image to process\")\n",
    "        return\n",
    "    \n",
    "    # Calculate number of rows and columns for subplot grid\n",
    "    n = len(block_sizes) + 1  # +1 for the original image\n",
    "    cols = 2\n",
    "    rows = (n + cols - 1) // cols  # Ceiling division\n",
    "    \n",
    "    plt.figure(figsize=(15, rows * 6))\n",
    "    \n",
    "    # Display original image\n",
    "    plt.subplot(rows, cols, 1)\n",
    "    plt.imshow(image)\n",
    "    plt.title('Original Image')\n",
    "    plt.axis('off')\n",
    "    \n",
    "    # Display resolution-reduced images\n",
    "    for i, size in enumerate(block_sizes, 2):\n",
    "        reduced = reduce_spatial_resolution(image, size)\n",
    "        \n",
    "        # Resize the reduced image to original dimensions for better comparison\n",
    "        h, w = image.shape[:2]\n",
    "        reduced_resized = cv2.resize(reduced, (w, h), interpolation=cv2.INTER_NEAREST)\n",
    "        \n",
    "        plt.subplot(rows, cols, i)\n",
    "        plt.imshow(reduced_resized)\n",
    "        plt.title(f'{size}x{size} Block Averaging')\n",
    "        plt.axis('off')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    return\n",
    "\n",
    "# Example usage (uncomment to test):\n",
    "# if original_image is not None:\n",
    "#     block_sizes = [3, 5, 7]\n",
    "#     display_resolution_reduction_results(original_image, block_sizes)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1d689727",
   "metadata": {},
   "source": [
    "## Demonstration: Running All Tasks\n",
    "\n",
    "Uncomment and run the cell below to process a sample image with all the implemented operations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "05a64984",
   "metadata": {},
   "outputs": [],
   "source": [
    "def run_all_tasks(image_path):\n",
    "    \"\"\"\n",
    "    Run all image processing tasks on the specified image\n",
    "    \n",
    "    Args:\n",
    "        image_path (str): Path to the image file\n",
    "    \"\"\"\n",
    "    print(\"Loading image...\")\n",
    "    image = load_and_display_image(image_path)\n",
    "    \n",
    "    if image is None:\n",
    "        print(\"Failed to load image. Please check the image path.\")\n",
    "        return\n",
    "    \n",
    "    print(\"\\n\" + \"-\"*50)\n",
    "    print(\"Task 1: Reducing Intensity Levels\")\n",
    "    print(\"-\"*50)\n",
    "    levels_list = [128, 64, 32, 16, 8, 4, 2]\n",
    "    display_intensity_reduction_results(image, levels_list)\n",
    "    \n",
    "    print(\"\\n\" + \"-\"*50)\n",
    "    print(\"Task 2: Spatial Averaging\")\n",
    "    print(\"-\"*50)\n",
    "    kernel_sizes = [3, 10, 20]\n",
    "    display_spatial_averaging_results(image, kernel_sizes)\n",
    "    \n",
    "    print(\"\\n\" + \"-\"*50)\n",
    "    print(\"Task 3: Image Rotation\")\n",
    "    print(\"-\"*50)\n",
    "    angles = [45, 90]\n",
    "    display_rotation_results(image, angles)\n",
    "    \n",
    "    print(\"\\n\" + \"-\"*50)\n",
    "    print(\"Task 4: Spatial Resolution Reduction by Block Averaging\")\n",
    "    print(\"-\"*50)\n",
    "    block_sizes = [3, 5, 7]\n",
    "    display_resolution_reduction_results(image, block_sizes)\n",
    "\n",
    "# To run all tasks, uncomment the line below and provide the path to your image\n",
    "# run_all_tasks('test_image.jpg')  # Replace with your image path"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5a8df2ef",
   "metadata": {},
   "source": [
    "## Conclusion\n",
    "\n",
    "This notebook implements all the required image processing operations for EC7212 Take Home Assignment 1:\n",
    "\n",
    "1. **Intensity Level Reduction**: Reduces the number of intensity levels from 256 to any desired power of 2.\n",
    "2. **Spatial Averaging**: Performs spatial averaging with 3x3, 10x10, and 20x20 neighborhoods.\n",
    "3. **Image Rotation**: Rotates images by 45 and 90 degrees.\n",
    "4. **Spatial Resolution Reduction**: Reduces spatial resolution by averaging non-overlapping blocks of sizes 3x3, 5x5, and 7x7.\n",
    "\n",
    "To use this notebook:\n",
    "1. Replace the image path in the `run_all_tasks` function with your own image path\n",
    "2. Uncomment the `run_all_tasks` call at the bottom of the notebook\n",
    "3. Run all cells to see the results\n",
    "\n",
    "Submission information: Code and results with GitHub link"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
